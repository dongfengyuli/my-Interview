# **HTTP面试题（一）：HTTP、HTTPS、URI、URL、HTTP方法**

文章目录
HTTP面试题
HTTP与HTTPs的区别
什么是HTTP无状态？怎么解决？
URI和URL区别
（1）URI
（2）URL
（3）URN
（4）小结
常见的HTTP方法有哪些？

HTTP面试题
HTTP与HTTPs的区别
HTTP是不安全的，HTTPs是安全的
HTTP的标准端口号是80，HTTPs的标准端口号是443
OSI网络模型中，HTTP工作于应用层，HTTPs的安全传输机制工作于传输层
HTTPs中“s”指代安全套接层SSL
HTTP无法加密，HTTPs会对传输数据进行加密（安全）
HTTP无需证书，HTTPs需要CA机构wosign颁发的SSL证书
什么是HTTP无状态？怎么解决？
无状态： 协议对事物的处理没有记忆，如果后面的操作需要前面的信息则需要重登

例：网站登录账户后，点击页面内的链接跳转，登录状态就会消失，需要再登录

解决： 利用cookie&session

cookie就相当于一个通信证，保存着用户信息，第一次访问后server会给客户端发送一个cookie，客户端保存到当地。当客户端第二次访问服务器时，将cookie一并发送，服务器就知道是“老用户”

URI和URL区别
（1）URI
URI（Uniform Resource Identifier 统一资源标识符）用来唯一标识一个资源

URI是抽象的

Web上可用的每种资源（HTML文档，图像，视频，程序）都是由URI定位的
URI一般由三部分组成：
访问资源的命名机制
存放资源的主机名
资源自身的名称（由路径给出，强调资源本身）
URI定位了你要的资源是什么类型，存放地方的名称，资源的名称

URI告诉你这个东西是什么

（2）URL
URL（Uniform Resource Locator 统一资源定位符）
URL是一种具体的URI，URL可以标识一个资源（是什么），而且告诉这个资源去哪怎么获取

URL主要用于各种www客户程序和服务器程序
URL一般也是三部分组成：
协议（服务方式）
存有该资源的主机IP地址（有时也包含端口号）
主机资源的具体地址（目录、文件名）
URL告诉了资源是什么、资源在哪、资源怎么获取

（3）URN
URN（Uniform Resource Name 同一资源命名符）通过名字标识资源

（4）小结
URI： 抽象的，高层次概念定义
URL： 具体的，一种具体的URI

常见的HTTP方法有哪些？
GET： 用于请求已被URI识别的资源，可以通过URL传参给服务器
POST： 用于传输信息给服务器，主要功能与GET类似，但POST安全性更高，一般推荐使用POST
PUT： 传输文件，报文主体中包含文件内容，保存到对应的URI处
DELETE： 删除文件，与PUT方法相反，删除对应URI位置的文件
HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效
OPTIONS： 查询相应的URI支持的HTTP方法


# **HTTP面试题（二）：HTTP请求报文和响应报文格式**

文章目录
HTTP请求报文和响应报文格式
【1】请求报文
【2】响应报文
【3】常见的首部字段
HTTP请求报文和响应报文格式
【1】请求报文
请求报文包含四个部分：

请求行：包含HTTP版本号、请求方法、URI……
请求首部字段
空行
请求内容实体

在这里插入图片描述
【2】响应报文
响应报文包含四部分：

状态行：响应状态码、HTTP版本信息
响应首部字段
空行
响应内容实体

在这里插入图片描述
【3】常见的首部字段
通用首部字段：

HTTP请求报文和响应报文都包含的字段

Date：创建报文的时间
Connection：连接的管理
Cache-Control：缓存的控制
Transfer-Encoding：传输编码控制
请求首部字段：

HTTP请求报文的常用首部字段

HOST：请求资源所在的服务器
Accept：可处理的媒体类型
Accept-Charset：可接收的字符集
Accept-Encoding：可接收的内容编码
Accept-Language：可接收的自然语言
响应报文字段：

HTTP响应报文的常用首部字段

Accept-Range：可接收的字节范围
Location：令客户端重定向的URI
Server：HTTP服务器的安装信息
实体首部字段：

请求报文和响应报文的实体部分的常用首部字段

Allow：资源可支持的HTTP方法
Content-Type：实体类型（例文本、图像、视频……）
Content-Encoding：实体适用的编码方式
Content-Language：实体的自然语言
Content-Length：实体主体的字节数
Content-Range：实体主体的范围

HTTP报文的组成
请求报文：
    --请求行(请求方法、请求URL、HTTP协议及版本)
    --请求头部
    --空行
    --请求体
响应报文：
    --状态行(状态码)
    --响应头部
    --空行
    --响应体

# **HTTP面试题（三）：HTTPS工作原理**

文章目录
HTTPS工作原理
在这里插入图片描述
握手过程
HTTPS的特点
HTTPS工作原理
在这里插入图片描述
浏览器向服务器发送HTTPS服务请求，在传输数据之前，进行一次握手

握手的目的：

确立双方加密传输的密码信息
做一次传输测试（利用随机生成的随机数）
TSL/SSL使用了非对称加密、对称加密、Hash算法

握手过程
在这里插入图片描述

1.浏览器请求https服务，并将自己的一套加密规则发送给网站
2.服务器从中选择一组加密算法，并将自己的身份信息以证书的形式回给浏览器
证书中包含：身份信息、公钥、证书颁发机构……

3.浏览器收到证书后：

A.验证证书合法性（颁发机构是否合法、网站地址正确与否……）
若证书受信，浏览器地址栏会出现一个锁头
在这里插入图片描述

B.证书受信后，浏览器随机生成一串随机数（用于测试），并使用证书中的公钥对随机数加密，将其发送给服务器
4.服务器利用自己的私钥进行解密，完成一次测试

HTTPS的特点
    HTTPS协议需要向CA申请证书，一般都需要付费
    HTTPS具有安全性的SSL安全套接层传输协议。HTTP则是明文传输
    HTTPS的连接要进行一次握手，可靠性更高。HTTP则是无状态连接
    

# **HTTP面试题（四）：一次完整的HTTP请求所经历的7个步骤**

HTTP通信7个步骤
在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间要经历7个步骤

1.建立TCP连接
Web浏览器首先要通过网络与Web服务器之间通过TCP建立连接，TCP与IP协议共同构建Internet
（1）HTTP协议是比TCP处于更高层的应用层协议，只有当低层协议建立练接之后才能进行更高层次的连接
（2）TCP连接的端口号一般是80
2.Web浏览器向Web服务器发送请求行
    建立TCP连接之后，Web浏览器会向Web服务器发送请求命令
3.Web浏览器向服务器发送请求头
    浏览器发送请求信息之后，还要以头信息的形式发送相关信息，并以空行代表发送结束
4.Web服务器应答
    Web服务器接收请求后返回应答，第一部分是协议的版本号和应答状态码
    例：“HTTP/1.1 200OK”

5.Web服务器发送应答头
    服务器也会随着应答发送一些相关信息，并以空行代表发送结束
6.Web服务器发送数据
    Web服务器向浏览器发送头信息之后，就以Content-Type格式发送用户所请求的信息
7.Web服务器关闭TCP连接
    一般情况下，一旦Web服务器向浏览器发送请求数据后，就要关闭TCP连接了
    若浏览器或者服务器的头信息中加入了这样一段代码：
    connection：Keep-alive
    则TCP连接会保持打开状态，可以继续通过相同的连接发送请求
    
# **HTTP面试题（五）：常见的HTTP相应状态码**

常见的HTTP状态码
【1】2XX
2开头的状态码都表示请求被正确处理

200：请求被正确处理
204：请求被受理但无资源返回
206：客户端只请求资源的一部分
服务器只对请求的部分资源执行GET方法，相应的报文部分通过Content-Range指定范围的资源

【2】3XX
3开头的状态码表示需要进一步操作（重定向）

301：永久性重定向
302：临时重定向
303：与302类似，只希望客户端在请求一个URI时，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
【3】4XX
4开头的状态码一般都是客户端相关问题

400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止访问
404：服务器找不到对应资源
【4】5XX
5字开头的状态码一般是服务器端相关问题

500：服务器内部错误
503：服务器正忙


# **HTTP面试题（六）：HTTP1.1新版本的特性**

1.默认持久连接
    只要客户端或服务器端没有明确说明要断开TCP连接，则一直保持连接状态
    
    同一个客户端可以发送多个HTTP请求
    减少通信量
2.管线化
    客户端可以同时发送多个HTTP请求，不用一个个等待响应

3.断点续传
    报文实体部分实现分块传输
    
# **HTTP面试题（七）：HTTP协议的优化方法**

HTTP优化方法
1.TCP复用 （负载均衡）
将多个客户端的HTTP请求放到同一个TCP连接上传输

2.HTTP复用
一个客户端的多个HTTP请求放到一个TCP连接上传输（==不断开TCP连接）

目前的HTTP1.1版本已经默认不断开TCP连接了

3.压缩：将文本内容压缩，节省带宽
4.内容缓存：常用的内容直接缓存到客户端，需要时直接从内存读取
5.SSL加速：使用SSL安全套接层对HTTP加密，在通道内加密并加速
6.TCP缓冲
通过采用TCP缓冲技术，提高服务器响应和处理效率，减少由于通信链路问题给服务器造成的连接负担

# **计算机网络面试题（八）：TCP三次握手（超重点！！！）**

TCP三次握手（面试重点）
几个重要标号：SYN、ACK

    SYN：SYN=1代表建立TCP连接
    ACK：（acknowledge character 确认字符）确认字段
    SYN=1，ACK=0：表示客户端请求TCP连接，但还没有确认
    SYN=1，ACK=1：表示服务器确认TCP连接


TCP三次握手过程：
1.客户端发送建立TCP连接的请求报文

请求报文中包含：
SYN=1表示要建立TCP连接
seq=x序列号，x为随机生成数值

2. 服务端回复客户端的连接请求

回复报文中包含：
SYN=1
ACK确认字符：ACK=x+1是在客户端发送过来的序列号seq的基础上＋1，告诉客户端TCP连接确认了
seq序列号：seq=y由服务端随机生成的序列号
3. 客户端收到回复后再发送给服务端

回复报文中包含
SYN=1
ACK=y+1
seq=x+1
整个过程：SYN=1一直不变，生成的ack确认字符会在上一个seq序列号的基础上+1

# **计算机网络面试题（九）：TCP四次挥手**

TCP四次挥手
挥手重要标号：FIN

    FIN=1 代表申请断开TCP连接

    确认字符ACK含义：说明当前这个报文是针对之前的哪个报文的验证。因为在TCP连接上会有很多请求（例如管线化）
    序列号seq含义：代表当前这个报文的序号
TCP四次挥手过程：

1.客户端发送断开TCP连接的请求报文
报文：FIN=1， seq=x
    FIN=1：代表请求断开TCP连接
    seq=x：给这个请求打一个标号，x是生成的随机数
2.服务端回复客户端的断开请求
报文： ACK=x+1， seq=y

    ACK=x+1：确认字符，在发送端的序列号x上面+1，这样就说明了是针对客户端序列号是x的报文的确认
    seq=y：给当前这个回复报文随机生成一个序列号（相当于标记）
    序列号seq相当于是给当前报文的一个标号，方便识别。一个TCP连接上面可能会有很多的报文来往，故需要这样一个标号

3.服务端在第一次回复之后不会马上就断开TCP连接，而是会先确保断开前，所传输的数据是否已经传输完成了（分手了也得把东西收拾完）

确认完毕后再回复一个报文

报文：FIN=1，ACK=x+1， seq=z
    FIN=1：代表断开TCP连接
    ACK=x+1：依然是针对上序列号是x的客户端请求的确认报文
    seq=z：给当前这个报文一个标号
4.客户端收到服务端的回复后再知会一声
报文：ACK=y+1，seq=h
    ACK=y+1：代表是针对标号是y的服务端报文的确认字符
    seq=h：给当前报文一个标号

# **计算机网络面试题（十）：TCP连接过程客户端和服务端状态**

1.开始前，客户端和服务端都是关闭的
    客户端：closed状态
    服务端：closed状态
2.服务器创建socket后开始监听
    服务端：listen状态
3.客户端请求建立TCP连接，向服务端发送SYN报文
    客户端：SYN_SEND状态
4.服务器收到客户端的报文后向客户端发送ACK和SYN报文
    服务端：SYN_RCVD状态
5.客户端收到ACK和SYN后向服务器再回一个ACK
    客户端：ESTABLISHED状态
6.服务端收到客户端的ACK后变为ESTABLISHED状态
    服务端：ESTABLISHED状态
    
# **计算机网络面试题（十一）：TCP4次挥手客户端和服务端状态**

由于TCP通信是全双工的，断开连接比建立连接要复杂

1.客户端向服务端发送FIN报文，请求断开TCP连接
客户端状态：FIN_WAIT1

2.服务端收到FIN，向客户端发送ACK
服务端状态：CLOSE_WAIT

3.客户端收到ACK后，此刻连接其实已经断开一半了，若服务器还有数据要传输，则继续传输
客户端状态：FIN_WAIT2

4.当服务端数据传输完毕，发送FIN报文给客户端
服务端状态：LAST_ACK

5.客户端收到服务端的第二个FIN后，回复ACK
客户端状态：TIME_WAIT

6.经过2MSL时间后，客户端关闭
客户端状态：CLOSED

7.服务端收到客户端的ACK后关闭
服务端状态：CLOSED

补充：CLOSEING状态
当客户端发送FIN请求断开TCP连接后，并没有收到客户端的ACK，而是直接收到了FIN，即跳过了第二阶段！！！！这是由于网络传输意外发送，ACK包丢失了，则此刻客户端进入CLOSEDING状态


# **计算机网络面试题（十二）：HTTP和HTTPS的区别**

HTTP和HTTPS的区别：

1.HTTP与HTTPS的URL开头不一样
HTTP：http：//……
HTTPS：https：//……
2.HTTP默认端口80，HTTPS默认端口443
3.HTTP是未经安全加密的协议，传输过程中容易被监听，数据容易被窃取，发送方和接收方容易被伪造
4.HTTPS是安全协议，通过密钥交换算法-签名算法-对称加密算法-摘要算法进行安全保障

# **计算机网络面试题（十三）：HTTP请求中：GET和POST区别**

区别一：用途不同
    GET：一般用于请求
    例如：你在浏览器地址栏输入一个URL，其实是发送了一个请求，请求服务器的某个资源
    
    POST：一般用于表单提交
    表单就是浏览器和服务器之间的数据传输装备。POST相当于将信息提交给服务器，然后等待服务器响应

    GET方法类似于pull（拉）：从服务器拉资源下来
    POST方法类似于push（推）：将数据推给服务器
区别二：安全性不同
    GET：不安全，GET的请求是明文传输，简而言之就是你的请求信息是直接跟在URL后面的，用户都看得到
    例如：……/index/demo_form.asp?name='Y'&passwords='123'
    账户信息直接显示出来了
    
    POST：安全，POST方法会将信息放在请求体body中，用户是看不到的
    POST ……/index/demo_form.asp HTTP/1.1
    HOST：……
    name=‘Y’&passwords=‘123’
    信息不对外公开

区别三：数据长度限制
    GET：对传输的数据长度有限制
    因为其是明文传输，总不能让URL很长很长吧
    
    POST：对数据长度没有限制，因为数据都是放在消息体中的
区别四：是否会自动缓存
    GET：GET请求会被浏览器自动缓存
    POST：缓存需要手动设置
区别五：反复操作
    GET：GET请求在浏览器反复的回退/前进是无害的
    POST：一旦回退则要重新提交表单
区别六：TCP数据报
    GET：GET请求会在发送过程中产生一个TCP数据报
    浏览器会将http header和数据data一起发送出去，服务器响应200（返回请求的数据）
    
    POST：POST在提交过程中会产生两个TCP数据报
    浏览器先发送header，等待服务器响应100 continue
    浏览器再发送form，服务器响应200 OK
    
# **计算机网络面试题（十四）：TCP和UDP的区别**

TCP与UDP都位于网络模型中的传输层，负责传输应用层产生的数据

【1】UDP
UDP（User Datagram Protocol 用户数据报协议）：UDP不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输

数据报是与分组交换网络关联的传输单元

UDP特点：

    UDP低延迟
    UDP能够发送大量数据包
    UDP能够允许DNS查找（DNS是应用层协议）
【2】TCP
TCP（Transfer Control Protocol 传输控制协议）：通过三次握手建立TCP连接，一旦建立就可以发生数据，传输完成之后，会通过关闭虚拟电路来断开连接

TCP特点：

    TCP可以确保连接的建立和数据包发送可靠性
    TCP支持差错重传
    TCP支持拥塞控制，能够在网络发生堵塞的情况下延迟发送
    TCP能够提供差错检验，甄别有害数据包
【3】TCP和UDP对比
TCP	                    UDP
面向连接的	            无连接的
先建立连接，在发送数据	    无需连接，直接发送大量数据
顺序排列数据包	            数据包相互独立
传输速度较慢	            传输速度较快
头部字节20	            头部字节8
错误校验并恢复	            差错校验但丢弃错误数据包
有发送确认	            无发送确认
握手：SYN、SYN-ACK、ACK	无握手
可靠的	                不能保证数据传送到


*TCP是重量级的：在发送任何数据前，TCP都需要三次握手建立连接
*UDP是轻量级的：没有跟踪连接、消息排列等

# **计算机网络面试题（十五）：HTTP无状态协议是什么？怎么解决的？**

HTTP无状态协议:
无状态协议（Stateless Protocol）是指浏览器对于事物的处理没有记忆功能

例如：通过账户密码登录进了一个网站，当再次进入时则需要重新输入账户密码……

HTTP就是一种无状态协议，它对用户的操作没有记忆功能。为了解决这种情况，引出了Cookie&Session机制，让浏览器具备了记忆功能


Cookie&Session机制:
当服务器第一次收到请求时，会主动开辟一块session空间（即创建了session对象），同时生成一个sessionid
服务器在给浏览器回复响应时，会在响应头添加set-cookie: JSESSIONID=XXXXX，将sessionid回复给浏览器
客户端收到响应后，在本地设置一个对应JSESSIONID=XXXXX的cookie信息
cookie（饼干）是有过期时间的，过期时间就是浏览器会话结束——关闭网站



在此之后，客户端每次再向同一个网站发送请求时，请求头部都会带上cookie信息（包含了sessionid）

服务端在收到请求后，读取cookie信息，获取sessionid，在session空间中找到对应的信息进行比对

浏览器获得了记忆功能


JWT机制:
JWT（JSON Web Token）

token：令牌

JWT的功能也是让浏览器具有了记忆功能

JWT是保存在客户端的，广泛应用于单点登录

JWT特点：

JWT的cookie信息是保存在客户端的
JWT直接进行本地校验即可，验证完毕后，这个token就会在session中随请求一起发送给服务端。这样节省了服务端资源，并且token可以进行多次验证

JWT可以实现跨域认证
cookies只能用于单个节点的域/子域。如果需要通过第三个节点访问，就会被禁止。JWT可以通过多个节点进行用户认证

# **计算机网络面试题（十六）：HTTP1.0/1.1/2.0版本了解不？**
文章目录
    HTTP1.0
    HTTP1.1
    HTTP2.0
HTTP1.0
    HTTP1.0是1996年引入的
    HTTP1.0仅提供了最基本的认证，用户名和密码都未加密
    HTTP1.0仅支持短连接，每次发送数据都会经过TCP三次握手和四次挥手，效率低
    HTTP1.0只使用了header的if=modified-Since和Expires作为缓存失效的标准
    HTTP1.0不支持端点续传，每次发送数据都会发送全部数据
    HTTP1.0认为每台计算机都只能绑定一个IP地址，不支持虚拟网络
HTTP1.1
    HTTP1.1是1999年引入的
    HTTP1.1使用了摘要算法进行身份验证
    HTTP1.1默认使用长连接
    只需要建立一次连接，可以传输多次数据，传输完成之后，只需要一次切断即可。通过请求头的keep-alive设置
    
    HTTP1.1支持端点续传
    通过请求头的Range实现
    
    HTTP1.1使用了虚拟网络
    在一台物理服务器上可以存在多个虚拟主机，共享一个IP地址

HTTP2.0
    2015年建立
    
    头部压缩：利用HPACK算法进行压缩
    由于HTTP1.1头部经常出现Cookie、Accept、Sever、Range等字段可能会占用几百到几千字节，而body有时只有几十字节（“头重身轻”）
    
    二进制格式：HTTP2.0选择了更靠近TCP/IP的二进制格式，抛弃了ASCII码，提高了解析效率
    
    强化安全：HTTP2.0一般都跑在HTTPS上
    
    多路复用：一个连接上可以有多个请求
    

# **计算机网络面试题（十七）：地址栏输入URL后发生了什么？**



# **计算机网络面试题（十八）：HTTPS工作原理**


# **计算机网络面试题（十九）：TCP三次握手，为什么是三次？**

TCP
TCP是一种面向对象的单播协议（一对一），在发送数据前，通信双方必须要在彼此之间建立一条连接

连接：其实已一条虚拟的概念，具体是指客户端和服务端的内存里保存的一份关于对方的信息，例如：IP地址、端口号……

TCP可以看成是一种字节流，TCP会处理IP层及以下层的丢包、重复和错误问题。在连接的建立过程中，通信双方需要交换一些连接的参数，这些参数放在TCP报文的首部

TCP协议提供了一种可靠、面向连接的、字节流、传输层的服务

采用三次握手建立连接
采用四次挥手断开连接
TCP为什么采用三次握手？
握手的目的：建立可靠连接
三次握手的目的：让通信双方都能确认自身和对方具有正确的收发能力
第三握手还有一个功能：防止失效的连接请求到达服务器，服务器错误的打开了失效连接

1.第一次握手：客户端发送网络包，服务端接受网路包
客户端发送完之后，属于“懵逼”状态
服务端接受到网络包后可以得出结论：客户端具有发送能力，自身具备接受能力

2.第二次握手：服务端发送网络包，客户端接受网络包
服务端发送完之后，进入“懵逼”状态
客户端接受到网络包之后得出结论：基于上一个发送的网络包服务端接收到了，所以服务端具有收发能力，我具有收发能力
注意：此时只是客户端知道双方具有收发能力，服务端仅仅知道客户端有发送能力，自己有接受能力

3.第三次握手：客户端发送网络包，服务端接受网络包
此时服务端也知道了双方都具有收发能力

经历了三次握手，客户端和服务端才都知道双方具有收发能力，之后可以正常通信了

如何理解： 每一次握手之后你会发现，只有接受方能得出结论，发送方啥也不知道

我发包了，到没？发出去没？

总结
综上所述，必须要经过三次握手过程才能让客户端和服务端都知道双方具有正常的收发能力，两次做不到。


# **计算机网络面试题（二十）：TCP四次挥手，为什么要四次？**

TCP连接是双向传输的对等模式（即双方都可以同时向对方发送/接受数据），当有一方要关闭连接时，会发生FIN告知对方，对方回一个ACK则一个方向上的连接关闭了

需要四次挥手才能断开连接是因为：TCP是双向对等传输，故有两个方向的连接，需要两个FIN才能断开

当服务端收到客户端发送过来的FIN断开请求时，回复ACK后只是断开了client -> server方向的连接，服务端还可以继续向客户端发送数据（若数据没有发送完）。数据发送完后，服务端也发送一个FIN，客户端回复ACK，则全部断开了

总结
TCP是全双工通信，不能单方面完全断开连接

客户端发送FIN：只能断开客户端向服务端方向的连接
服务端发送FIN：只能断开服务端向客户端方向的连接

# **计算机网络面试题（二十一）：TCP长连接和短连接**

TCP长短连接的区别
【1】短连接
客户端向服务端发送消息，服务端回应客户端一次读写就完成了
双方都可以发送关闭操作
一般都是客户端先发起

短连接一般只会在client/server之间传递一次读写操作

【2】长连接
客户端和服务端完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接

在长连接的应用场景下，客户端一般不会主动关闭连接
服务端会采取一些策略：
关闭一些长时间没有读写操作的连接
限制客户端最长连接数量

# **计算机网络面试题（二十二）：TCP沾包、拆包以及解决办法**

为什么会发生TCP粘包、拆包？
发生TCP粘包、拆包主要是由于下面一些原因：
1. 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
2.应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
3.进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
4.接收方法不及时读取套接字缓冲区数据，这将发生粘包。

粘包、拆包解决办法
TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：
1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。